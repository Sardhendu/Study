autoMPG.trainDataNumericSignificant <- autoMPG.trainDataNumeric[significantFeatures]
autoMPG.testDataNumericSignificant <- autoMPG.testDataNumeric[significantFeatures]
autoMPG.numeric.model2.lin <- lm(mpg~horsepower + weight,  data=autoMPG.trainDataNumericSignificant)
summary(autoMPG.numeric.model2.lin)
autoMPG.testDataNumericSignificant$mpg_hat <- predict(autoMPG.numeric.model2.lin, autoMPG.testDataNumericSignificant)
autoMPG.testDataNumericSignificant$residue <- autoMPG.testDataNumericSignificant$mpg_hat - autoMPG.testDataNumericSignificant$mpg
autoMPG.numeric.model2.lin.SSE <- sum((autoMPG.testDataNumericSignificant$residue)^2)
autoMPG.numeric.model2.lin.SSR <- sum((autoMPG.testDataNumericSignificant$mpg_hat - mean(autoMPG.testDataNumericSignificant$mpg))^2)
autoMPG.numeric.model2.lin.SST <- sum((autoMPG.testDataNumericSignificant$mpg - mean(autoMPG.testDataNumericSignificant$mpg))^2)
stopifnot(autoMPG.numeric.model2.lin.SSE + autoMPG.numeric.model2.lin.SSR == autoMPG.numeric.model2.lin.SST)
autoMPG.numeric.model2.r_sq1 <- autoMPG.numeric.model2.lin.SSR / autoMPG.numeric.model2.lin.SST
autoMPG.numeric.model2.r_sq1
autoMPG.numeric.model2.r_sq2 <- autoMPG.numeric.model2.lin.SSR / (autoMPG.numeric.model2.lin.SSE + autoMPG.numeric.model2.lin.SSR)
autoMPG.numeric.model2.r_sq2
autoMPG.datumVarDtypeClean <- na.omit(autoMPG.datumVarDtype)
summary(autoMPG.numeric.model2.lin)
autoMPG.numeric.model2.r_sq2
autoMPG.datumVarDtypeClean <- na.omit(autoMPG.datumVarDtype)
autoMPG.dataBad <- autoMPG.datumVarDtypeClean[significantFeatures]
autoMPG.trainDataBad <- autoMPG.dataBad[trainIndices,]
autoMPG.trainDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[trainIndices]
autoMPG.testDataBad <- autoMPG.dataBad[-trainIndices,]
autoMPG.testDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[-trainIndices]
stopifnot(nrow(autoMPG.trainDataBad) + nrow(autoMPG.testDataBad) == nrow(autoMPG.datumVarDtypeClean))
yVariable <- "mpg"
xVariables <- c(names(autoMPG.trainDataBad))
xVariables <- xVariables[xVariables!= yVariable]
autoMPG.bad.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.bad.model.lin <- lm(autoMPG.bad.model, data=autoMPG.trainDataBad)
summary(autoMPG.bad.model.lin)
autoMPG.testDataBad$mpg_hat <- predict(autoMPG.bad.model.lin, autoMPG.testDataBad)
autoMPG.datumVarDtypeClean <- na.omit(autoMPG.datumVarDtype)
autoMPG.dataBad <- autoMPG.datumVarDtypeClean#[significantFeatures]
autoMPG.trainDataBad <- autoMPG.dataBad[trainIndices,]
autoMPG.trainDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[trainIndices]
autoMPG.testDataBad <- autoMPG.dataBad[-trainIndices,]
autoMPG.testDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[-trainIndices]
colnames(autoMPG.dataBad)
autoMPG.datumVarDtypeClean <- na.omit(autoMPG.datumVarDtype)
autoMPG.dataBad <- autoMPG.datumVarDtypeClean#[significantFeatures]
colnames(autoMPG.dataBad)
autoMPG.trainDataBad <- autoMPG.dataBad[trainIndices,]
autoMPG.trainDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[trainIndices]
autoMPG.testDataBad <- autoMPG.dataBad[-trainIndices,]
autoMPG.testDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[-trainIndices]
stopifnot(nrow(autoMPG.trainDataBad) + nrow(autoMPG.testDataBad) == nrow(autoMPG.datumVarDtypeClean))
yVariable <- "mpg"
xVariables <- c(names(autoMPG.trainDataBad))
xVariables <- xVariables[xVariables!= yVariable]
autoMPG.bad.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.bad.model.lin <- lm(autoMPG.bad.model, data=autoMPG.trainDataBad)
summary(autoMPG.bad.model.lin)
autoMPG.testDataBad$mpg_hat <- predict(autoMPG.bad.model.lin, autoMPG.testDataBad)
xVariables <- xVariables[xVariables!= "car_name"]
autoMPG.fixed.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.fixed.model.lin <- lm(autoMPG.fixed.model, data=autoMPG.trainDataBad)
summary(autoMPG.fixed.model.lin)
autoMPG.testDataFixed <- autoMPG.testDataBad
autoMPG.testDataFixed$car_name <- NULL                    # We dont need to do this (this is just redundant use of memory), this is just done for the continuity of the variables
autoMPG.testDataFixed$mpg_hat <- predict(autoMPG.fixed.model.lin, autoMPG.testDataFixed)
autoMPG.testDataFixed$residue <- autoMPG.testDataFixed$mpg_hat - autoMPG.testDataFixed$mpg
autoMPG.fixed.model.lin.SSE <- sum((autoMPG.testDataFixed$residue)^2)
autoMPG.fixed.model.lin.SSR <- sum((autoMPG.testDataFixed$mpg_hat - mean(autoMPG.testDataFixed$mpg))^2)
autoMPG.fixed.model.lin.SST <- sum((autoMPG.testDataFixed$mpg - mean(autoMPG.testDataFixed$mpg))^2)
stopifnot(autoMPG.fixed.model.lin.SSE + autoMPG.fixed.model.lin.SSR == autoMPG.fixed.model.lin.SST)
autoMPG.fixed.model.r_sq1 <- autoMPG.fixed.model.lin.SSR / autoMPG.fixed.model.lin.SST
autoMPG.fixed.model.r_sq1
autoMPG.fixed.model.r_sq2 <- autoMPG.fixed.model.lin.SSR/(autoMPG.fixed.model.lin.SSR + autoMPG.fixed.model.lin.SSE)
autoMPG.fixed.model.r_sq2
regression.Model <- lm(autoMPG.datumClean$mpg~autoMPG.datumClean$model_year)
summary(regression.Model)
summary(autoMPG.fixed.model.lin)
library(sqldf)
aliasDatumVarDtype <- autoMPG.datumVarDtype
groupTable <- sqldf("select model_year, count(mpg) as count, min(mpg) as min, max(mpg) as max, max(mpg)-min(mpg) as range from aliasDatumVarDtype group by model_year")
groupTable
modelYear <- as.integer(as.character(autoMPG.datumVarDtype$model_year))
dev.off()
plot(modelYear, autoMPG.datumVarDtype$mpg)
head(as.data.frame(c(modelYear,autoMPG.datumVarDtype$mpg)))
plot(modelYear, autoMPG.datumVarDtype$mpg)
regression.Model <- lm(autoMPG.datumClean$mpg~autoMPG.datumClean$model_year)
summary(regression.Model)
library(dplyr)
autoMPG.datumClean$mpgQuartile <- ntile(autoMPG.datumClean$mpg, 4)
tbl <- table(autoMPG.datumClean$mpgQuartile, autoMPG.datumClean$model_year)
chisq.test(tbl)
yVariable <- "mpg"
xVariables <- c("model_year", "weight","acceleration", "displacement")
autoMPG.best.model5 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model5.output <- buildModel(autoMPG.best.model5, autoMPG.trainDataLog, autoMPG.testDataLog)
buildModel <- function(model, trainDataIN, testDataIN){
linFit <- lm(model, data=trainDataIN)
y_hat <- predict(linFit, testDataIN)
residue <- y_hat - testDataIN$mpg
SSE <- sum((residue)^2)
SSR <- sum((y_hat - mean(testDataIN$mpg))^2)
SST <- sum((testDataIN$mpg - mean(testDataIN$mpg))^2)
SST2 <- SSE + SSR
return (list(linFit, y_hat, residue, SSE, SSR, SST, SST2))
}
yVariable <- "mpg"
xVariables <- c("model_year", "weight","acceleration", "displacement")
autoMPG.best.model5 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model5.output <- buildModel(autoMPG.best.model5, autoMPG.trainDataLog, autoMPG.testDataLog)
rm(list = ls())
url <- "https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data"
datum <- read.table(url, header=FALSE)
autoMPG.datum <- data.frame(datum)
head(autoMPG.datum)
featureNames <- c("mpg", "cylinders", "displacement", "horsepower", "weight", "acceleration", "model_year", "origin", "car_name")
names(autoMPG.datum) <- featureNames
autoMPG.orig_numericCols <- names(which(sapply(autoMPG.datum, is.numeric)))
autoMPG.orig_numericCols
autoMPG.orig_factorCols <- names(which(sapply(autoMPG.datum, is.factor)))
autoMPG.orig_factorCols
uniqueCount <- function (feature){
print (length(unlist(unique(autoMPG.datum[feature]))))
}
sapply(featureNames, FUN=uniqueCount)
autoMPG.datumVarDtype <- autoMPG.datum
autoMPG.datumVarDtype$mpg <- as.numeric(as.character(autoMPG.datum$mpg))
autoMPG.datumVarDtype$displacement <- as.numeric(as.character(autoMPG.datum$displacement))
autoMPG.datumVarDtype$horsepower <- as.numeric(as.character(autoMPG.datum$horsepower))
autoMPG.datumVarDtype$weight <- as.numeric(as.character(autoMPG.datum$weight))
autoMPG.datumVarDtype$acceleration <- as.numeric(as.character(autoMPG.datum$acceleration))
autoMPG.datumVarDtype$cylinders <- as.factor(as.character(autoMPG.datum$cylinders))
autoMPG.datumVarDtype$model_year <- as.factor(as.character(autoMPG.datum$model_year))
autoMPG.datumVarDtype$origin <- as.factor(as.character(autoMPG.datum$origin))
head(autoMPG.datumVarDtype)
autoMPG.datumClean <- autoMPG.datumVarDtype
autoMPG.datumClean$car_name <- NULL
head(autoMPG.datumClean)
sapply(autoMPG.datumClean, class)
autoMPG.datumCleanAlias <- autoMPG.datumClean
library(ggplot2)
library(grid)
library(gridExtra)
autoMPG.numericCols <- c("mpg", "displacement", "horsepower", "weight", "acceleration")
autoMPG.discreteCols <- c("cylinders", "model_year", "origin")
summary(autoMPG.datumClean)
dev.off()
par(mfrow=c(2,3))
autoMPG.crearteBoxPlots <- function (column_name, dataIN){
boxplot(dataIN[column_name], horizontal = TRUE,  main= column_name)
stripchart(dataIN[column_name], add = TRUE, pch = 20, col = 'red')
}
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.datumClean)
dev.off()
plot(autoMPG.datumClean[, autoMPG.numericCols])
library(reshape2)
dev.off()
ggplot(data = melt(autoMPG.datumClean), mapping = aes(x = value)) +
geom_histogram(bins = 10) + facet_wrap(~variable, scales = 'free_x')
datumClean_alias <- autoMPG.datumClean[, autoMPG.discreteCols]
discreteColTable <- sqldf("select 'cylinders' as feature, cylinders as category, count(cylinders) as count from datumClean_alias group by cylinders union select 'model_year' as feature, model_year as category, count(model_year) as count from datumClean_alias group by model_year union select 'origin' as feature, origin as category, count(origin) as count from datumClean_alias group by origin")
dev.off()
par(mfrow=c(2,2))
barPlots <- function(featureVector, dataIN){
tab <- table(dataIN[featureVector])
barplot(tab, main=featureVector, xlab="Feature Categories")
}
sapply(autoMPG.discreteCols, FUN=barPlots, autoMPG.datumClean)
dev.off()
par(mfrow=c(3,2))
levels(autoMPG.datumClean$cylinders)
autoMPG.cylinder3 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 3), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder3)
dev.off()
par(mfrow=c(3,2))
autoMPG.cylinder4 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 4), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder4)
dev.off()
par(mfrow=c(3,2))
autoMPG.cylinder5 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 5), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder5)
dev.off()
par(mfrow=c(2,3))
autoMPG.cylinder6 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 6), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder6)
dev.off()
par(mfrow=c(3,2))
autoMPG.cylinder8 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 8), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder8)
dev.off()
par(mfrow=c(2,3))
levels(autoMPG.datumClean$origin)
autoMPG.origin1 <- autoMPG.datumClean[which(autoMPG.datumClean$origin == 1), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.origin1)
dev.off()
par(mfrow=c(2,3))
levels(autoMPG.datumClean$origin)
autoMPG.origin2 <- autoMPG.datumClean[which(autoMPG.datumClean$origin == 2), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.origin2)
dev.off()
par(mfrow=c(2,3))
levels(autoMPG.datumClean$origin)
autoMPG.origin3 <- autoMPG.datumClean[which(autoMPG.datumClean$origin == 3), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.origin3)
library(ggplot2)
library(corrplot)
autoMPG.datumCleanNumeric <- autoMPG.datumClean[,autoMPG.numericCols]    # Fetching the data frame with only numeric columns
autoMPG.cor_matrix <- cor(na.omit(autoMPG.datumCleanNumeric))         # Building the correlation plot
dev.off()                                       # Closes all the previous plot windows
corrplot(autoMPG.cor_matrix, method="number")
colnames(autoMPG.datumClean)[colSums(is.na(autoMPG.datumClean)) > 0]
summary(autoMPG.datumClean$horsepower)
library(dplyr)
library(plyr)
cleanData <- function (data_in, NA_column, column_wrt, replaceType='avg', cleanType='replace'){
data_NA <- subset(data_in, is.na(data_in[NA_column]))
data_NotNA <- setdiff(data_in, data_NA)
if (cleanType=='remove'){
return (data_NotNA)
}
else if (cleanType=='replace'){
# Find the median of the horsepower column given the column_wrt
unq_vals <- unique(data_NA[column_wrt])
query <- sprintf("select cylinders, %s(%s) as nwHP from data_NotNA group by cylinders having cylinders in unq_vals", replaceType, NA_column)
newMedianTable <- sqldf(query)
for (cylinder_num in newMedianTable[column_wrt][,]){
data_NA[data_NA[column_wrt] == cylinder_num , ][NA_column] <- newMedianTable[newMedianTable[column_wrt] == cylinder_num ,]["nwHP"]
}
return (rbind.fill(data_NotNA,data_NA))
}
else{
return (NULL)
}
}
autoMPG.datumClean <- cleanData(autoMPG.datumCleanAlias,
'horsepower',
'cylinders',
replaceType='avg',
cleanType='remove')
dim(autoMPG.datumClean)
stopifnot(dim(autoMPG.datumClean) == dim(autoMPG.datumCleanAlias))
stopifnot(sum(is.na(autoMPG.datumClean)) == 0)
library('caret')
trainPrcnt <- 0.8
testPrnct <- 0.2
set.seed(32455)
trainIndices <- createDataPartition(y = autoMPG.datumClean$mpg, p = trainPrcnt, list = FALSE)
autoMPG.trainData <- autoMPG.datumClean[trainIndices,]
autoMPG.testData <- autoMPG.datumClean[-trainIndices,]
stopifnot(nrow(autoMPG.trainData) + nrow(autoMPG.testData) == nrow(autoMPG.datumClean))
head(autoMPG.trainData)
dim(autoMPG.trainData)
head(autoMPG.testData)
dim(autoMPG.testData)
autoMPG.trainDataNumeric <- autoMPG.trainData[, autoMPG.numericCols]
autoMPG.testDataNumeric <- autoMPG.testData[, autoMPG.numericCols]
summary(autoMPG.trainDataNumeric)
summary(autoMPG.testDataNumeric)
dev.off()
par(mfrow=c(2,2))
plot(mpg~displacement, autoMPG.trainDataNumeric)
plot(mpg~horsepower, autoMPG.trainDataNumeric)
plot(mpg~weight, autoMPG.trainDataNumeric)
plot(mpg~acceleration, autoMPG.trainDataNumeric)
autoMPG.numeric.model.lin <- lm(mpg~displacement + horsepower + weight + acceleration, data=autoMPG.trainDataNumeric)
summary(autoMPG.numeric.model.lin)
autoMPG.testDataNumeric$mpg_hat <- predict(autoMPG.numeric.model.lin, autoMPG.testDataNumeric)
autoMPG.testDataNumeric$residue <- autoMPG.testDataNumeric$mpg_hat - autoMPG.testDataNumeric$mpg
autoMPG.numeric.model.lin.SSE <- sum((autoMPG.testDataNumeric$residue)^2)
autoMPG.numeric.model.lin.SSR <- sum((autoMPG.testDataNumeric$mpg_hat - mean(autoMPG.testDataNumeric$mpg))^2)
autoMPG.numeric.model.lin.SST <- sum((autoMPG.testDataNumeric$mpg - mean(autoMPG.testDataNumeric$mpg))^2)
stopifnot(autoMPG.numeric.model.lin.SSE + autoMPG.numeric.model.lin.SSR == autoMPG.numeric.model.lin.SST)
autoMPG.numeric.model.r_sq1 <- autoMPG.numeric.model.lin.SSR / autoMPG.numeric.model.lin.SST
autoMPG.numeric.model.r_sq1
autoMPG.numeric.model.r_sq2 <- autoMPG.numeric.model.lin.SSR / (autoMPG.numeric.model.lin.SSE+autoMPG.numeric.model.lin.SSR)
autoMPG.numeric.model.r_sq2
getSignificantFeatures <- function(inputSummary, dependent, alpha){
signFeatureIndice <- which(inputSummary['Pr(>|t|)']<=alpha)
signFeatureIndice <- signFeatureIndice[signFeatureIndice!=1]   # remove the intercept column
return (c(row.names(inputSummary[signFeatureIndice,]), dependent))
}
significantFeatures <- getSignificantFeatures(as.data.frame(summary(autoMPG.numeric.model.lin)$coefficients), dependent="mpg", alpha=0.05)
autoMPG.trainDataNumericSignificant <- autoMPG.trainDataNumeric[significantFeatures]
autoMPG.testDataNumericSignificant <- autoMPG.testDataNumeric[significantFeatures]
autoMPG.numeric.model2.lin <- lm(mpg~horsepower + weight,  data=autoMPG.trainDataNumericSignificant)
summary(autoMPG.numeric.model2.lin)
autoMPG.testDataNumericSignificant$mpg_hat <- predict(autoMPG.numeric.model2.lin, autoMPG.testDataNumericSignificant)
autoMPG.testDataNumericSignificant$residue <- autoMPG.testDataNumericSignificant$mpg_hat - autoMPG.testDataNumericSignificant$mpg
autoMPG.numeric.model2.lin.SSE <- sum((autoMPG.testDataNumericSignificant$residue)^2)
autoMPG.numeric.model2.lin.SSR <- sum((autoMPG.testDataNumericSignificant$mpg_hat - mean(autoMPG.testDataNumericSignificant$mpg))^2)
autoMPG.numeric.model2.lin.SST <- sum((autoMPG.testDataNumericSignificant$mpg - mean(autoMPG.testDataNumericSignificant$mpg))^2)
stopifnot(autoMPG.numeric.model2.lin.SSE + autoMPG.numeric.model2.lin.SSR == autoMPG.numeric.model2.lin.SST)
autoMPG.numeric.model2.r_sq1 <- autoMPG.numeric.model2.lin.SSR / autoMPG.numeric.model2.lin.SST
autoMPG.numeric.model2.r_sq1
autoMPG.numeric.model2.r_sq2 <- autoMPG.numeric.model2.lin.SSR / (autoMPG.numeric.model2.lin.SSE + autoMPG.numeric.model2.lin.SSR)
autoMPG.numeric.model2.r_sq2
autoMPG.datumVarDtypeClean <- na.omit(autoMPG.datumVarDtype)
autoMPG.dataBad <- autoMPG.datumVarDtypeClean#[significantFeatures]
colnames(autoMPG.dataBad)
autoMPG.trainDataBad <- autoMPG.dataBad[trainIndices,]
autoMPG.trainDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[trainIndices]
autoMPG.testDataBad <- autoMPG.dataBad[-trainIndices,]
autoMPG.testDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[-trainIndices]
stopifnot(nrow(autoMPG.trainDataBad) + nrow(autoMPG.testDataBad) == nrow(autoMPG.datumVarDtypeClean))
yVariable <- "mpg"
xVariables <- c(names(autoMPG.trainDataBad))
xVariables <- xVariables[xVariables!= yVariable]
autoMPG.bad.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.bad.model.lin <- lm(autoMPG.bad.model, data=autoMPG.trainDataBad)
summary(autoMPG.bad.model.lin)
autoMPG.testDataBad$mpg_hat <- predict(autoMPG.bad.model.lin, autoMPG.testDataBad)
xVariables <- xVariables[xVariables!= "car_name"]
autoMPG.fixed.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.fixed.model.lin <- lm(autoMPG.fixed.model, data=autoMPG.trainDataBad)
summary(autoMPG.fixed.model.lin)
autoMPG.testDataFixed <- autoMPG.testDataBad
autoMPG.testDataFixed$car_name <- NULL                    # We dont need to do this (this is just redundant use of memory), this is just done for the continuity of the variables
autoMPG.testDataFixed$mpg_hat <- predict(autoMPG.fixed.model.lin, autoMPG.testDataFixed)
autoMPG.testDataFixed$residue <- autoMPG.testDataFixed$mpg_hat - autoMPG.testDataFixed$mpg
autoMPG.fixed.model.lin.SSE <- sum((autoMPG.testDataFixed$residue)^2)
autoMPG.fixed.model.lin.SSR <- sum((autoMPG.testDataFixed$mpg_hat - mean(autoMPG.testDataFixed$mpg))^2)
autoMPG.fixed.model.lin.SST <- sum((autoMPG.testDataFixed$mpg - mean(autoMPG.testDataFixed$mpg))^2)
stopifnot(autoMPG.fixed.model.lin.SSE + autoMPG.fixed.model.lin.SSR == autoMPG.fixed.model.lin.SST)
autoMPG.fixed.model.r_sq1 <- autoMPG.fixed.model.lin.SSR / autoMPG.fixed.model.lin.SST
autoMPG.fixed.model.r_sq1
autoMPG.fixed.model.r_sq2 <- autoMPG.fixed.model.lin.SSR/(autoMPG.fixed.model.lin.SSR + autoMPG.fixed.model.lin.SSE)
autoMPG.fixed.model.r_sq2
library(RecordLinkage)
library(sqldf)
car_names <- autoMPG.datumVarDtype$car_name
brandName <- function (carname){
cname <- as.character(carname)
initials <- unlist(strsplit(cname, " "))[1]
if (initials == 'vw'){
return("volkswagen")
}
return (initials)
}
initials <- sapply(car_names, FUN=brandName)
initials <- data.frame(initials)
uniqueCount <- sqldf("select initials as brand, count(*) as occurance from initials group by initials")  # We see that some spellings are wrong
uniqueCount
library('stringdist')
library('dplyr')
jaroDistMatrix <- 1-stringdistmatrix(uniqueBrands$brand,useNames="strings",method="jw")
jaroDistMatrix <- data.frame(as.matrix(jaroDistMatrix))
simThresh <- 0.8
idx <- apply(jaroDistMatrix, 2, function(x) x >0.8)
idx <- apply(idx, 1:2, function(x) if(isTRUE(x)) x<-1 else x<-NA)
matrix_abs <- na.omit(melt(idx))
sqldf("select a.Var1, b.Var1 from matrix_abs as a join matrix_abs as b on a.Var1=b.Var2")
initialsNew <- initials
aa <- function(row, dfIN) {
origName <- dfIN[row,"Var1"]
print (as.character(origName))
indices <- which(initialsNew == as.character(origName))
print (indices)
initialsNew[indices,"initials"] <- as.character(origName)
}
sapply(1:nrow(matrix_abs), FUN=aa, matrix_abs)
regression.Model <- lm(autoMPG.datumClean$mpg~autoMPG.datumClean$model_year)
summary(regression.Model)
summary(autoMPG.fixed.model.lin)
library(sqldf)
aliasDatumVarDtype <- autoMPG.datumVarDtype
groupTable <- sqldf("select model_year, count(mpg) as count, min(mpg) as min, max(mpg) as max, max(mpg)-min(mpg) as range from aliasDatumVarDtype group by model_year")
groupTable
modelYear <- as.integer(as.character(autoMPG.datumVarDtype$model_year))
dev.off()
plot(modelYear, autoMPG.datumVarDtype$mpg)
head(as.data.frame(c(modelYear,autoMPG.datumVarDtype$mpg)))
library(dplyr)
autoMPG.datumClean$mpgQuartile <- ntile(autoMPG.datumClean$mpg, 4)
tbl <- table(autoMPG.datumClean$mpgQuartile, autoMPG.datumClean$model_year)
chisq.test(tbl)
buildModel <- function(model, trainDataIN, testDataIN){
linFit <- lm(model, data=trainDataIN)
y_hat <- predict(linFit, testDataIN)
residue <- y_hat - testDataIN$mpg
SSE <- sum((residue)^2)
SSR <- sum((y_hat - mean(testDataIN$mpg))^2)
SST <- sum((testDataIN$mpg - mean(testDataIN$mpg))^2)
SST2 <- SSE + SSR
return (list(linFit, y_hat, residue, SSE, SSR, SST, SST2))
}
library(reshape2)
dev.off()
ggplot(data = melt(log(autoMPG.datumClean[autoMPG.numericCols])), mapping = aes(x = value)) +
geom_histogram(bins = 10) + facet_wrap(~variable, scales = 'free_x')
trainPrcnt <- 0.8
testPrnct <- 0.2
set.seed(4673)
trainIndicesNew <- createDataPartition(y = autoMPG.datumClean$mpg, p = trainPrcnt, list = FALSE)
autoMPG.trainDataNew <- autoMPG.datumClean[trainIndicesNew,]
autoMPG.testDataNew <- autoMPG.datumClean[-trainIndicesNew,]
stopifnot(nrow(autoMPG.trainDataNew) + nrow(autoMPG.testDataLog) == nrow(autoMPG.datumClean))
head(autoMPG.trainDataNew)
head(autoMPG.testDataNew)
dim(autoMPG.trainDataNew)
dim(autoMPG.testDataNew)
autoMPG.dataLogTransformed <- autoMPG.datumClean
autoMPG.dataLogTransformed[,autoMPG.numericCols] <- log(autoMPG.dataLogTransformed[,autoMPG.numericCols])
head(autoMPG.dataLogTransformed)
trainIndicesLog <- createDataPartition(y = autoMPG.dataLogTransformed$mpg, p = trainPrcnt, list = FALSE)
autoMPG.trainDataLog <- autoMPG.dataLogTransformed[trainIndicesLog,]
autoMPG.testDataLog <- autoMPG.dataLogTransformed[-trainIndicesLog,]
stopifnot(nrow(autoMPG.trainDataLog) + nrow(autoMPG.testDataLog) == nrow(autoMPG.dataLogTransformed))
head(autoMPG.trainDataLog)
head(autoMPG.testDataLog)
dim(autoMPG.trainDataLog)
dim(autoMPG.testDataLog)
xVariables <- c("model_year", "origin", "horsepower")
yVariable <- "mpg"
autoMPG.best.model1 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model1.output <- buildModel(autoMPG.best.model1, autoMPG.trainDataNew, autoMPG.testDataNew)
summary(model1.output[[1]])
autoMPG.testDataNew$mpg_hat <- model1.output[[2]]
autoMPG.testDataNew$residue <- model1.output[[3]]
head(autoMPG.testDataNew)
autoMPG.best.model1.lin.SSE <- model1.output[[4]]
autoMPG.best.model1.lin.SSR <- model1.output[[5]]
autoMPG.best.model1.lin.SST <- model1.output[[6]]
autoMPG.best.model1.lin.SST2 <- model1.output[[7]]
stopifnot(autoMPG.best.model1.lin.SSE + autoMPG.best.model1.lin.SSR == autoMPG.best.model1.lin.SST)
autoMPG.best.model1.r_sq1 <- autoMPG.best.model1.lin.SSR / autoMPG.best.model1.lin.SST
autoMPG.best.model1.r_sq1
autoMPG.best.model1.r_sq2 <- autoMPG.best.model1.lin.SSR / autoMPG.best.model1.lin.SST2
autoMPG.best.model1.r_sq2
xVariables <- c("cylinders", "displacement","horsepower", "weight", "acceleration", "model_year", "origin")
yVariable <- "mpg"
autoMPG.best.model2 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model2.output <- buildModel(autoMPG.best.model2, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model2.output[[1]])
autoMPG.testDataLog$mpg_hat1 <- model2.output[[2]]
autoMPG.testDataLog$residue1 <- model2.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model2.lin.SSE <- model2.output[[4]]
autoMPG.best.model2.lin.SSR <- model2.output[[5]]
autoMPG.best.model2.lin.SST <- model2.output[[6]]
autoMPG.best.model2.lin.SST2 <- model2.output[[7]]
stopifnot(autoMPG.best.model2.lin.SSE + autoMPG.best.model2.lin.SSR == autoMPG.best.model2.lin.SST)
autoMPG.best.model2.r_sq1 <- autoMPG.best.model2.lin.SSR / autoMPG.best.model2.lin.SST
autoMPG.best.model2.r_sq1
autoMPG.best.model2.r_sq2 <- autoMPG.best.model2.lin.SSR / autoMPG.best.model2.lin.SST2
autoMPG.best.model2.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "cylinders","weight","displacement")
autoMPG.best.model3 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model3.output <- buildModel(autoMPG.best.model3, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model3.output[[1]])
autoMPG.testDataLog$mpg_hat3 <- model3.output[[2]]
autoMPG.testDataLog$residue3 <- model3.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model3.lin.SSE <- model3.output[[4]]
autoMPG.best.model3.lin.SSR <- model3.output[[5]]
autoMPG.best.model3.lin.SST <- model3.output[[6]]
autoMPG.best.model3.lin.SST2 <- model3.output[[7]]
stopifnot(autoMPG.best.model3.lin.SSE + autoMPG.best.model3.lin.SSR == autoMPG.best.model3.lin.SST)
autoMPG.best.model3.r_sq1 <- autoMPG.best.model3.lin.SSR / autoMPG.best.model3.lin.SST
autoMPG.best.model3.r_sq1
autoMPG.best.model3.r_sq2 <- autoMPG.best.model3.lin.SSR / autoMPG.best.model3.lin.SST2
autoMPG.best.model3.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "weight","displacement")
autoMPG.best.model4 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model4.output <- buildModel(autoMPG.best.model4, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model4.output[[1]])
autoMPG.testDataLog$mpg_hat4 <- model4.output[[2]]
autoMPG.testDataLog$residue4 <- model4.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model4.lin.SSE <- model4.output[[4]]
autoMPG.best.model4.lin.SSR <- model4.output[[5]]
autoMPG.best.model4.lin.SST <- model4.output[[6]]
autoMPG.best.model4.lin.SST2 <- model4.output[[7]]
stopifnot(autoMPG.best.model4.lin.SSE + autoMPG.best.model4.lin.SSR == autoMPG.best.model4.lin.SST)
autoMPG.best.model4.r_sq1 <- autoMPG.best.model4.lin.SSR / autoMPG.best.model4.lin.SST
autoMPG.best.model4.r_sq1
autoMPG.best.model4.r_sq2 <- autoMPG.best.model4.lin.SSR / autoMPG.best.model4.lin.SST2
autoMPG.best.model4.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "weight","acceleration", "displacement")
autoMPG.best.model5 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model5.output <- buildModel(autoMPG.best.model5, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model5.output[[1]])
autoMPG.testDataLog$mpg_hat5 <- model5.output[[2]]
autoMPG.testDataLog$residue5 <- model5.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model5.lin.SSE <- model5.output[[4]]
autoMPG.best.model5.lin.SSR <- model5.output[[5]]
autoMPG.best.model5.lin.SST <- model5.output[[6]]
autoMPG.best.model5.lin.SST2 <- model5.output[[7]]
stopifnot(autoMPG.best.model5.lin.SSE + autoMPG.best.model5.lin.SSR == autoMPG.best.model5.lin.SST)
autoMPG.best.model5.r_sq1 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST
autoMPG.best.model4.r_sq1
autoMPG.best.model5.r_sq2 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "cylinders","weight","acceleration", "displacement")
autoMPG.best.model5 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model5.output <- buildModel(autoMPG.best.model5, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model5.output[[1]])
autoMPG.testDataLog$mpg_hat5 <- model5.output[[2]]
autoMPG.testDataLog$residue5 <- model5.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model5.lin.SSE <- model5.output[[4]]
autoMPG.best.model5.lin.SSR <- model5.output[[5]]
autoMPG.best.model5.lin.SST <- model5.output[[6]]
autoMPG.best.model5.lin.SST2 <- model5.output[[7]]
stopifnot(autoMPG.best.model5.lin.SSE + autoMPG.best.model5.lin.SSR == autoMPG.best.model5.lin.SST)
autoMPG.best.model5.r_sq1 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST
autoMPG.best.model4.r_sq1
autoMPG.best.model5.r_sq2 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
