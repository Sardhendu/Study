dev.off()
par(mfrow=c(3,2))
autoMPG.cylinder5 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 5), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder5)
dev.off()
par(mfrow=c(2,3))
autoMPG.cylinder6 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 6), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder6)
dev.off()
par(mfrow=c(3,2))
autoMPG.cylinder8 <- autoMPG.datumClean[which(autoMPG.datumClean$cylinders == 8), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.cylinder8)
dev.off()
par(mfrow=c(2,3))
levels(autoMPG.datumClean$origin)
autoMPG.origin1 <- autoMPG.datumClean[which(autoMPG.datumClean$origin == 1), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.origin1)
dev.off()
par(mfrow=c(2,3))
levels(autoMPG.datumClean$origin)
autoMPG.origin2 <- autoMPG.datumClean[which(autoMPG.datumClean$origin == 2), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.origin2)
dev.off()
par(mfrow=c(2,3))
levels(autoMPG.datumClean$origin)
autoMPG.origin3 <- autoMPG.datumClean[which(autoMPG.datumClean$origin == 3), ]
sapply(autoMPG.numericCols, FUN=autoMPG.crearteBoxPlots, dataIN=autoMPG.origin3)
library(ggplot2)
library(corrplot)
autoMPG.datumCleanNumeric <- autoMPG.datumClean[,autoMPG.numericCols]    # Fetching the data frame with only numeric columns
autoMPG.cor_matrix <- cor(na.omit(autoMPG.datumCleanNumeric))         # Building the correlation plot
dev.off()                                       # Closes all the previous plot windows
corrplot(autoMPG.cor_matrix, method="number")
colnames(autoMPG.datumClean)[colSums(is.na(autoMPG.datumClean)) > 0]
summary(autoMPG.datumClean$horsepower)
library(dplyr)
library(plyr)
cleanData <- function (data_in, NA_column, column_wrt, replaceType='avg', cleanType='replace'){
data_NA <- subset(data_in, is.na(data_in[NA_column]))
data_NotNA <- setdiff(data_in, data_NA)
if (cleanType=='remove'){
return (data_NotNA)
}
else if (cleanType=='replace'){
# Find the median of the horsepower column given the column_wrt
unq_vals <- unique(data_NA[column_wrt])
query <- sprintf("select cylinders, %s(%s) as nwHP from data_NotNA group by cylinders having cylinders in unq_vals", replaceType, NA_column)
newMedianTable <- sqldf(query)
for (cylinder_num in newMedianTable[column_wrt][,]){
data_NA[data_NA[column_wrt] == cylinder_num , ][NA_column] <- newMedianTable[newMedianTable[column_wrt] == cylinder_num ,]["nwHP"]
}
return (rbind.fill(data_NotNA,data_NA))
}
else{
return (NULL)
}
}
autoMPG.datumClean <- cleanData(autoMPG.datumCleanAlias,
'horsepower',
'cylinders',
replaceType='avg',
cleanType='remove')
dim(autoMPG.datumClean)
stopifnot(dim(autoMPG.datumClean) == dim(autoMPG.datumCleanAlias))
stopifnot(sum(is.na(autoMPG.datumClean)) == 0)
library('caret')
trainPrcnt <- 0.8
testPrnct <- 0.2
set.seed(32455)
trainIndices <- createDataPartition(y = autoMPG.datumClean$mpg, p = trainPrcnt, list = FALSE)
autoMPG.trainData <- autoMPG.datumClean[trainIndices,]
autoMPG.testData <- autoMPG.datumClean[-trainIndices,]
stopifnot(nrow(autoMPG.trainData) + nrow(autoMPG.testData) == nrow(autoMPG.datumClean))
head(autoMPG.trainData)
dim(autoMPG.trainData)
head(autoMPG.testData)
dim(autoMPG.testData)
autoMPG.trainDataNumeric <- autoMPG.trainData[, autoMPG.numericCols]
autoMPG.testDataNumeric <- autoMPG.testData[, autoMPG.numericCols]
summary(autoMPG.trainDataNumeric)
summary(autoMPG.testDataNumeric)
dev.off()
par(mfrow=c(2,2))
plot(mpg~displacement, autoMPG.trainDataNumeric)
plot(mpg~horsepower, autoMPG.trainDataNumeric)
plot(mpg~weight, autoMPG.trainDataNumeric)
plot(mpg~acceleration, autoMPG.trainDataNumeric)
autoMPG.numeric.model.lin <- lm(mpg~displacement + horsepower + weight + acceleration, data=autoMPG.trainDataNumeric)
summary(autoMPG.numeric.model.lin)
autoMPG.testDataNumeric$mpg_hat <- predict(autoMPG.numeric.model.lin, autoMPG.testDataNumeric)
autoMPG.testDataNumeric$residue <- autoMPG.testDataNumeric$mpg_hat - autoMPG.testDataNumeric$mpg
autoMPG.numeric.model.lin.SSE <- sum((autoMPG.testDataNumeric$residue)^2)
autoMPG.numeric.model.lin.SSR <- sum((autoMPG.testDataNumeric$mpg_hat - mean(autoMPG.testDataNumeric$mpg))^2)
autoMPG.numeric.model.lin.SST <- sum((autoMPG.testDataNumeric$mpg - mean(autoMPG.testDataNumeric$mpg))^2)
stopifnot(autoMPG.numeric.model.lin.SSE + autoMPG.numeric.model.lin.SSR == autoMPG.numeric.model.lin.SST)
autoMPG.numeric.model.r_sq1 <- autoMPG.numeric.model.lin.SSR / autoMPG.numeric.model.lin.SST
autoMPG.numeric.model.r_sq1
autoMPG.numeric.model.r_sq2 <- autoMPG.numeric.model.lin.SSR / (autoMPG.numeric.model.lin.SSE+autoMPG.numeric.model.lin.SSR)
autoMPG.numeric.model.r_sq2
getSignificantFeatures <- function(inputSummary, dependent, alpha){
signFeatureIndice <- which(inputSummary['Pr(>|t|)']<=alpha)
signFeatureIndice <- signFeatureIndice[signFeatureIndice!=1]   # remove the intercept column
return (c(row.names(inputSummary[signFeatureIndice,]), dependent))
}
significantFeatures <- getSignificantFeatures(as.data.frame(summary(autoMPG.numeric.model.lin)$coefficients), dependent="mpg", alpha=0.05)
autoMPG.trainDataNumericSignificant <- autoMPG.trainDataNumeric[significantFeatures]
autoMPG.testDataNumericSignificant <- autoMPG.testDataNumeric[significantFeatures]
autoMPG.numeric.model2.lin <- lm(mpg~horsepower + weight,  data=autoMPG.trainDataNumericSignificant)
summary(autoMPG.numeric.model2.lin)
autoMPG.testDataNumericSignificant$mpg_hat <- predict(autoMPG.numeric.model2.lin, autoMPG.testDataNumericSignificant)
autoMPG.testDataNumericSignificant$residue <- autoMPG.testDataNumericSignificant$mpg_hat - autoMPG.testDataNumericSignificant$mpg
autoMPG.numeric.model2.lin.SSE <- sum((autoMPG.testDataNumericSignificant$residue)^2)
autoMPG.numeric.model2.lin.SSR <- sum((autoMPG.testDataNumericSignificant$mpg_hat - mean(autoMPG.testDataNumericSignificant$mpg))^2)
autoMPG.numeric.model2.lin.SST <- sum((autoMPG.testDataNumericSignificant$mpg - mean(autoMPG.testDataNumericSignificant$mpg))^2)
stopifnot(autoMPG.numeric.model2.lin.SSE + autoMPG.numeric.model2.lin.SSR == autoMPG.numeric.model2.lin.SST)
autoMPG.numeric.model2.r_sq1 <- autoMPG.numeric.model2.lin.SSR / autoMPG.numeric.model2.lin.SST
autoMPG.numeric.model2.r_sq1
autoMPG.numeric.model2.r_sq2 <- autoMPG.numeric.model2.lin.SSR / (autoMPG.numeric.model2.lin.SSE + autoMPG.numeric.model2.lin.SSR)
autoMPG.numeric.model2.r_sq2
autoMPG.datumVarDtypeClean <- na.omit(autoMPG.datumVarDtype)
autoMPG.dataBad <- autoMPG.datumVarDtypeClean#[significantFeatures]
colnames(autoMPG.dataBad)
autoMPG.trainDataBad <- autoMPG.dataBad[trainIndices,]
autoMPG.trainDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[trainIndices]
autoMPG.testDataBad <- autoMPG.dataBad[-trainIndices,]
autoMPG.testDataBad$car_name <- autoMPG.datumVarDtypeClean$car_name[-trainIndices]
stopifnot(nrow(autoMPG.trainDataBad) + nrow(autoMPG.testDataBad) == nrow(autoMPG.datumVarDtypeClean))
yVariable <- "mpg"
xVariables <- c(names(autoMPG.trainDataBad))
xVariables <- xVariables[xVariables!= yVariable]
autoMPG.bad.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.bad.model.lin <- lm(autoMPG.bad.model, data=autoMPG.trainDataBad)
summary(autoMPG.bad.model.lin)
autoMPG.testDataBad$mpg_hat <- predict(autoMPG.bad.model.lin, autoMPG.testDataBad)
xVariables <- xVariables[xVariables!= "car_name"]
autoMPG.fixed.model <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
autoMPG.fixed.model.lin <- lm(autoMPG.fixed.model, data=autoMPG.trainDataBad)
summary(autoMPG.fixed.model.lin)
autoMPG.testDataFixed <- autoMPG.testDataBad
autoMPG.testDataFixed$car_name <- NULL                    # We dont need to do this (this is just redundant use of memory), this is just done for the continuity of the variables
autoMPG.testDataFixed$mpg_hat <- predict(autoMPG.fixed.model.lin, autoMPG.testDataFixed)
autoMPG.testDataFixed$residue <- autoMPG.testDataFixed$mpg_hat - autoMPG.testDataFixed$mpg
autoMPG.fixed.model.lin.SSE <- sum((autoMPG.testDataFixed$residue)^2)
autoMPG.fixed.model.lin.SSR <- sum((autoMPG.testDataFixed$mpg_hat - mean(autoMPG.testDataFixed$mpg))^2)
autoMPG.fixed.model.lin.SST <- sum((autoMPG.testDataFixed$mpg - mean(autoMPG.testDataFixed$mpg))^2)
stopifnot(autoMPG.fixed.model.lin.SSE + autoMPG.fixed.model.lin.SSR == autoMPG.fixed.model.lin.SST)
autoMPG.fixed.model.r_sq1 <- autoMPG.fixed.model.lin.SSR / autoMPG.fixed.model.lin.SST
autoMPG.fixed.model.r_sq1
autoMPG.fixed.model.r_sq2 <- autoMPG.fixed.model.lin.SSR/(autoMPG.fixed.model.lin.SSR + autoMPG.fixed.model.lin.SSE)
autoMPG.fixed.model.r_sq2
library(RecordLinkage)
library(sqldf)
car_names <- autoMPG.datumVarDtype$car_name
brandName <- function (carname){
cname <- as.character(carname)
initials <- unlist(strsplit(cname, " "))[1]
if (initials == 'vw'){
return("volkswagen")
}
return (initials)
}
initials <- sapply(car_names, FUN=brandName)
initials <- data.frame(initials)
uniqueCount <- sqldf("select initials as brand, count(*) as occurance from initials group by initials")  # We see that some spellings are wrong
uniqueCount
library('stringdist')
library('dplyr')
jaroDistMatrix <- 1-stringdistmatrix(uniqueBrands$brand,useNames="strings",method="jw")
jaroDistMatrix <- data.frame(as.matrix(jaroDistMatrix))
simThresh <- 0.8
idx <- apply(jaroDistMatrix, 2, function(x) x >0.8)
idx <- apply(idx, 1:2, function(x) if(isTRUE(x)) x<-1 else x<-NA)
matrix_abs <- na.omit(melt(idx))
sqldf("select a.Var1, b.Var1 from matrix_abs as a join matrix_abs as b on a.Var1=b.Var2")
initialsNew <- initials
aa <- function(row, dfIN) {
origName <- dfIN[row,"Var1"]
print (as.character(origName))
indices <- which(initialsNew == as.character(origName))
print (indices)
initialsNew[indices,"initials"] <- as.character(origName)
}
sapply(1:nrow(matrix_abs), FUN=aa, matrix_abs)
regression.Model <- lm(autoMPG.datumClean$mpg~autoMPG.datumClean$model_year)
summary(regression.Model)
summary(autoMPG.fixed.model.lin)
library(sqldf)
aliasDatumVarDtype <- autoMPG.datumVarDtype
groupTable <- sqldf("select model_year, count(mpg) as count, min(mpg) as min, max(mpg) as max, max(mpg)-min(mpg) as range from aliasDatumVarDtype group by model_year")
groupTable
modelYear <- as.integer(as.character(autoMPG.datumVarDtype$model_year))
dev.off()
plot(modelYear, autoMPG.datumVarDtype$mpg)
head(as.data.frame(c(modelYear,autoMPG.datumVarDtype$mpg)))
library(dplyr)
autoMPG.datumClean$mpgQuartile <- ntile(autoMPG.datumClean$mpg, 4)
tbl <- table(autoMPG.datumClean$mpgQuartile, autoMPG.datumClean$model_year)
chisq.test(tbl)
buildModel <- function(model, trainDataIN, testDataIN){
linFit <- lm(model, data=trainDataIN)
y_hat <- predict(linFit, testDataIN)
residue <- y_hat - testDataIN$mpg
SSE <- sum((residue)^2)
SSR <- sum((y_hat - mean(testDataIN$mpg))^2)
SST <- sum((testDataIN$mpg - mean(testDataIN$mpg))^2)
SST2 <- SSE + SSR
return (list(linFit, y_hat, residue, SSE, SSR, SST, SST2))
}
library(reshape2)
dev.off()
ggplot(data = melt(log(autoMPG.datumClean[autoMPG.numericCols])), mapping = aes(x = value)) +
geom_histogram(bins = 10) + facet_wrap(~variable, scales = 'free_x')
trainPrcnt <- 0.8
testPrnct <- 0.2
set.seed(4673)
trainIndicesNew <- createDataPartition(y = autoMPG.datumClean$mpg, p = trainPrcnt, list = FALSE)
autoMPG.trainDataNew <- autoMPG.datumClean[trainIndicesNew,]
autoMPG.testDataNew <- autoMPG.datumClean[-trainIndicesNew,]
stopifnot(nrow(autoMPG.trainDataNew) + nrow(autoMPG.testDataLog) == nrow(autoMPG.datumClean))
head(autoMPG.trainDataNew)
head(autoMPG.testDataNew)
dim(autoMPG.trainDataNew)
dim(autoMPG.testDataNew)
autoMPG.dataLogTransformed <- autoMPG.datumClean
autoMPG.dataLogTransformed[,autoMPG.numericCols] <- log(autoMPG.dataLogTransformed[,autoMPG.numericCols])
head(autoMPG.dataLogTransformed)
trainIndicesLog <- createDataPartition(y = autoMPG.dataLogTransformed$mpg, p = trainPrcnt, list = FALSE)
autoMPG.trainDataLog <- autoMPG.dataLogTransformed[trainIndicesLog,]
autoMPG.testDataLog <- autoMPG.dataLogTransformed[-trainIndicesLog,]
stopifnot(nrow(autoMPG.trainDataLog) + nrow(autoMPG.testDataLog) == nrow(autoMPG.dataLogTransformed))
head(autoMPG.trainDataLog)
head(autoMPG.testDataLog)
dim(autoMPG.trainDataLog)
dim(autoMPG.testDataLog)
xVariables <- c("model_year", "origin", "horsepower")
yVariable <- "mpg"
autoMPG.best.model1 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model1.output <- buildModel(autoMPG.best.model1, autoMPG.trainDataNew, autoMPG.testDataNew)
summary(model1.output[[1]])
autoMPG.testDataNew$mpg_hat <- model1.output[[2]]
autoMPG.testDataNew$residue <- model1.output[[3]]
head(autoMPG.testDataNew)
autoMPG.best.model1.lin.SSE <- model1.output[[4]]
autoMPG.best.model1.lin.SSR <- model1.output[[5]]
autoMPG.best.model1.lin.SST <- model1.output[[6]]
autoMPG.best.model1.lin.SST2 <- model1.output[[7]]
stopifnot(autoMPG.best.model1.lin.SSE + autoMPG.best.model1.lin.SSR == autoMPG.best.model1.lin.SST)
autoMPG.best.model1.r_sq1 <- autoMPG.best.model1.lin.SSR / autoMPG.best.model1.lin.SST
autoMPG.best.model1.r_sq1
autoMPG.best.model1.r_sq2 <- autoMPG.best.model1.lin.SSR / autoMPG.best.model1.lin.SST2
autoMPG.best.model1.r_sq2
xVariables <- c("cylinders", "displacement","horsepower", "weight", "acceleration", "model_year", "origin")
yVariable <- "mpg"
autoMPG.best.model2 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model2.output <- buildModel(autoMPG.best.model2, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model2.output[[1]])
autoMPG.testDataLog$mpg_hat1 <- model2.output[[2]]
autoMPG.testDataLog$residue1 <- model2.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model2.lin.SSE <- model2.output[[4]]
autoMPG.best.model2.lin.SSR <- model2.output[[5]]
autoMPG.best.model2.lin.SST <- model2.output[[6]]
autoMPG.best.model2.lin.SST2 <- model2.output[[7]]
stopifnot(autoMPG.best.model2.lin.SSE + autoMPG.best.model2.lin.SSR == autoMPG.best.model2.lin.SST)
autoMPG.best.model2.r_sq1 <- autoMPG.best.model2.lin.SSR / autoMPG.best.model2.lin.SST
autoMPG.best.model2.r_sq1
autoMPG.best.model2.r_sq2 <- autoMPG.best.model2.lin.SSR / autoMPG.best.model2.lin.SST2
autoMPG.best.model2.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "cylinders","weight","displacement")
autoMPG.best.model3 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model3.output <- buildModel(autoMPG.best.model3, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model3.output[[1]])
autoMPG.testDataLog$mpg_hat3 <- model3.output[[2]]
autoMPG.testDataLog$residue3 <- model3.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model3.lin.SSE <- model3.output[[4]]
autoMPG.best.model3.lin.SSR <- model3.output[[5]]
autoMPG.best.model3.lin.SST <- model3.output[[6]]
autoMPG.best.model3.lin.SST2 <- model3.output[[7]]
stopifnot(autoMPG.best.model3.lin.SSE + autoMPG.best.model3.lin.SSR == autoMPG.best.model3.lin.SST)
autoMPG.best.model3.r_sq1 <- autoMPG.best.model3.lin.SSR / autoMPG.best.model3.lin.SST
autoMPG.best.model3.r_sq1
autoMPG.best.model3.r_sq2 <- autoMPG.best.model3.lin.SSR / autoMPG.best.model3.lin.SST2
autoMPG.best.model3.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "weight","displacement")
autoMPG.best.model4 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model4.output <- buildModel(autoMPG.best.model4, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model4.output[[1]])
autoMPG.testDataLog$mpg_hat4 <- model4.output[[2]]
autoMPG.testDataLog$residue4 <- model4.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model4.lin.SSE <- model4.output[[4]]
autoMPG.best.model4.lin.SSR <- model4.output[[5]]
autoMPG.best.model4.lin.SST <- model4.output[[6]]
autoMPG.best.model4.lin.SST2 <- model4.output[[7]]
stopifnot(autoMPG.best.model4.lin.SSE + autoMPG.best.model4.lin.SSR == autoMPG.best.model4.lin.SST)
autoMPG.best.model4.r_sq1 <- autoMPG.best.model4.lin.SSR / autoMPG.best.model4.lin.SST
autoMPG.best.model4.r_sq1
autoMPG.best.model4.r_sq2 <- autoMPG.best.model4.lin.SSR / autoMPG.best.model4.lin.SST2
autoMPG.best.model4.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "weight","acceleration", "displacement")
autoMPG.best.model5 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model5.output <- buildModel(autoMPG.best.model5, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model5.output[[1]])
autoMPG.testDataLog$mpg_hat5 <- model5.output[[2]]
autoMPG.testDataLog$residue5 <- model5.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model5.lin.SSE <- model5.output[[4]]
autoMPG.best.model5.lin.SSR <- model5.output[[5]]
autoMPG.best.model5.lin.SST <- model5.output[[6]]
autoMPG.best.model5.lin.SST2 <- model5.output[[7]]
stopifnot(autoMPG.best.model5.lin.SSE + autoMPG.best.model5.lin.SSR == autoMPG.best.model5.lin.SST)
autoMPG.best.model5.r_sq1 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST
autoMPG.best.model4.r_sq1
autoMPG.best.model5.r_sq2 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
yVariable <- "mpg"
xVariables <- c("model_year", "cylinders","weight","acceleration", "displacement")
autoMPG.best.model5 <- as.formula(paste(yVariable, "~", paste(xVariables, collapse = '+ ')))
model5.output <- buildModel(autoMPG.best.model5, autoMPG.trainDataLog, autoMPG.testDataLog)
summary(model5.output[[1]])
autoMPG.testDataLog$mpg_hat5 <- model5.output[[2]]
autoMPG.testDataLog$residue5 <- model5.output[[3]]
head(autoMPG.testDataLog)
autoMPG.best.model5.lin.SSE <- model5.output[[4]]
autoMPG.best.model5.lin.SSR <- model5.output[[5]]
autoMPG.best.model5.lin.SST <- model5.output[[6]]
autoMPG.best.model5.lin.SST2 <- model5.output[[7]]
stopifnot(autoMPG.best.model5.lin.SSE + autoMPG.best.model5.lin.SSR == autoMPG.best.model5.lin.SST)
autoMPG.best.model5.r_sq1 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST
autoMPG.best.model4.r_sq1
autoMPG.best.model5.r_sq2 <- autoMPG.best.model5.lin.SSR / autoMPG.best.model5.lin.SST2
autoMPG.best.model5.r_sq2
autoMPG.best.model5.r_sq2
url <- 'http://www.umass.edu/statdata/statdata/data/lowbwt.xls'
library(gdata)
lbw <- read.xls(url)
names(lbw) <- tolower(names(lbw))
head(lbw)
set.seed(632)
x <- scale( cbind(x1,x2,x3,x4,x5,x6) )
lbw <- within(lbw, {
## race relabeling
race.cat <- factor(race, levels = 1:3, labels = c("White","Black","Other"))
## ftv (frequency of visit) relabeling
ftv.cat <- cut(ftv, breaks = c(-Inf, 0, 2, Inf), labels = c("None","Normal","Many"))
ftv.cat <- relevel(ftv.cat, ref = "Normal")
## ptl
preterm <- factor(ptl >= 1, levels = c(F,T), labels = c("0","1+"))
})
formulaStr <- 'bwt ~ age + lwt + race.cat + smoke + preterm + ht + ui + ftv.cat'
formula <- as.formula(formulaStr)
lm.full <- lm(formula, data = lbw)
lm.null <- lm(bwt ~ 1, data = lbw)
summary(lm.full)
summary(lm.null)
plot(lm.full)
plot(lm.null)
alpha <- .01
summary(lm.full)
tValues <- summary(lm.full)$coefficients[,4]
tValues
tValues <- sort(tValues, decreasing = TRUE)
tValues
varToDrop <- names(tValues[1])
varToDrop
dropVarFromFormula <- function(formulaStr, dropVar){
return(as.formula(paste0(formulaStr, ' - ', dropVar)))
}
newModelFormula <- dropVarFromFormula(formulaStr, dropVar = varToDrop)
newModel <- lm(newModelFormula, data = lbw)
summary(newModel)
drop1(update(lm.full, ~ . -age), test = "F")
drop1(update(lm.full, ~ . -age -ftv.cat), test = "F")
library(class)
library(MASS)
library(Hmisc)
library(klaR)
library(e1071)
library(kknn)
library(rpart)
library(boost)
library(mvtnorm)
library(multinomRob)
library(lars)
library(stats)
library(leaps)
install.packages('klaR')
install.packages('kknn')
install.packages('boost')
install.packages('lars')
install.packages('multinomRob')
library(class)
library(MASS)
library(Hmisc)
library(klaR)
library(e1071)
library(kknn)
library(rpart)
library(boost)
library(mvtnorm)
library(multinomRob)
library(lars)
library(stats)
library(leaps)
set.seed(632)
x1 <- runif(50, 0, 1)
x2 <- x1 + rnorm(50, 0, 0.25)
x3 <- (x1 + x2)/2 + runif(50, 0, 0.1)
x4 <- runif(50, 0, 1)
x5 <- (2*x4 + rnorm(50, 0, 0.25))/2 + runif(50, 0, 0.1)
x6 <- runif(50, 0, 1)
y <- (3 + x1 + x2 + 0.5*x3 + 0.75*x4 + 0.5*x5 + 0.5*x6 + rnorm(50, 0, 1))
x
?scale
x <- scale( cbind(x1,x2,x3,x4,x5,x6) )
x
trdata <- data.frame( cbind(x,y) )
names(trdata) <- c("sx1", "sx2", "sx3", "sx4", "sx5", "sx6", "y")
attach(trdata)
cor(trdata)
ols1 <- lm(y ~ sx1 + sx2 + sx3 + sx4 + sx5 + sx6)
summary(ols1)
ols2 <- lm(y ~ sx1 + sx2 + sx3 + sx4 + sx5)
summary(ols2)
ols3 <- lm(y ~ sx1 + sx2 + sx3 + sx5)
summary(ols3)
ols4 <- lm(y ~ sx1 + sx3 + sx5)
summary(ols4)
ols5 <- lm(y ~ sx1 + sx5)
summary(ols5)
ols6 <- step(ols1, direction="both")
summary(ols6)
las <- lars(x, y, type="lasso")
las
plot(las, plottype="coefficients")
x1 <- runif(50, 0, 1)
x2 <- x1 + rnorm(50, 0, 0.25)
x3 <- (x1 + x2)/2 + runif(50, 0, 0.1)
x4 <- runif(50, 0, 1)
x5 <- (2*x4 + rnorm(50, 0, 0.25))/2 + runif(50, 0, 0.1)
x6 <- runif(50, 0, 1)
y <- (3 + x1 + x2 + 0.5*x3 + 0.75*x4 + 0.5*x5 + 0.5*x6 + rnorm(50, 0, 1))
x <- scale( cbind(x1,x2,x3,x4,x5,x6) )
trdata <- data.frame( cbind(x,y) )
names(trdata) <- c("sx1", "sx2", "sx3", "sx4", "sx5", "sx6", "y")
attach(trdata)
cor(trdata)
las <- lars(x, y, type="lasso")
las
plot(las, plottype="coefficients")
set.seed(632)
x1 <- runif(50, 0, 1)
x2 <- x1 + rnorm(50, 0, 0.25)
x3 <- (x1 + x2)/2 + runif(50, 0, 0.1)
x4 <- runif(50, 0, 1)
x5 <- (2*x4 + rnorm(50, 0, 0.25))/2 + runif(50, 0, 0.1)
x6 <- runif(50, 0, 1)
y <- (3 + x1 + x2 + 0.5*x3 + 0.75*x4 + 0.5*x5 + 0.5*x6 + rnorm(50, 0, 1))
las <- lars(x, y, type="lasso")
las
plot(las, plottype="coefficients")
#
plot(las, plottype="Cp")
plot(las, plottype="coefficients")
set.seed(632)
x1 <- runif(50, 0, 1)
x2 <- x1 + rnorm(50, 0, 0.25)
x3 <- (x1 + x2)/2 + runif(50, 0, 0.1)
x4 <- runif(50, 0, 1)
x5 <- (2*x4 + rnorm(50, 0, 0.25))/2 + runif(50, 0, 0.1)
x6 <- runif(50, 0, 1)
y <- (3 + x1 + x2 + 0.5*x3 + 0.75*x4 + 0.5*x5 + 0.5*x6 + rnorm(50, 0, 1))
?scale
x <- scale( cbind(x1,x2,x3,x4,x5,x6) )
trdata <- data.frame( cbind(x,y) )
names(trdata) <- c("sx1", "sx2", "sx3", "sx4", "sx5", "sx6", "y")
attach(trdata)
cor(trdata)
las <- lars(x, y, type="lasso")
las
plot(las, plottype="coefficients")
plot(las, plottype="Cp")
cvlas <- cv.lars(x, y, type="lasso")
cvlas
cvlas$fraction
cvlas$fraction[which.min(cvlas$cv)]
which.min(cvlas$cv)
min(cvlas$cv)
frac <- cvlas$cv[which.min(cvlas$cv)]
frac
frac <- cvlas$fraction[which.min(cvlas$cv)]
frac
las.coef <- predict.lars(las, type="coefficients", mode="fraction", s=frac)
las.coef
las.coef
las.coef <- predict.lars(las, type="coefficients", mode="fraction", s=1)
las.coef
ols1
?model.matrix
?glmnet
install.packages('glmnet')
?glmnet
?plot.glmnet
??plot.glmnet
??plot.glmnet
